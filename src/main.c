#define _GNU_SOURCE  // Для getline(), basename() и других GNU-расширений
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <regex.h>    // Регулярные выражения для поиска вызовов функций
#include <libgen.h>   // basename() - получение имени файла из пути
#include <syslog.h>   // Системное логирование
#include <unistd.h>   // getuid(), getresuid(), seteuid()
#include <sys/types.h>
#include <pwd.h>      // getpwuid() - получение информации о пользователе
#include <sys/stat.h>

/*
 * МАССИВЫ ОПАСНЫХ ФУНКЦИЙ C
 * 
 * Опасные функции (уровень 2): 
 * Эти функции НЕПРАВИЛЬНО проверяют границы буферов и гарантированно
 * подвержены переполнению буфера при неправильном использовании.
 * 
 * Предупредительные функции (уровень 1):
 * Эти функции МОГУТ быть безопасными при правильном использовании,
 * но часто используются неправильно или требуют особого внимания.
 */
const char* dangerous[] = {
    "strcpy",    // Копирование строки без проверки длины
    "strcat",    // Конкатенация строк без проверки длины
    "sprintf",   // Форматированный вывод в строку без проверки длины
    "vsprintf",  // Вариативный форматированный вывод без проверки длины
    "gets",      // Чтение строки из stdin без ограничения длины (УДАЛЕНА из C11!)
    "realpath",  // Может переполнить буфер если результат длиннее буфера
    "getwd",     // Устаревшая, использует буфер фиксированного размера
    "confstr",   // Может переполнить буфер если значение длиннее буфера
    NULL         // Маркер конца массива
};

const char* warning[] = {
    "strncpy",    // Может не завершить строку нулём
    "strncat",    // Сложно правильно использовать, легко ошибиться с длиной
    "snprintf",   // Обычно безопасна, но нужно проверять возвращаемое значение
    "vsnprintf",  // Аналогично snprintf
    NULL          // Маркер конца массива
};

/*
 * ФУНКЦИЯ: is_dangerous()
 * 
 * Назначение: Определяет уровень опасности функции
 * 
 * Аргументы:
 *   f - имя функции для проверки
 * 
 * Возвращает:
 *   2 - функция опасна (гарантированно может вызвать переполнение буфера)
 *   1 - функция требует предупреждения (может быть опасна при неправильном использовании)
 *   0 - функция безопасна или не входит в списки
 */
int is_dangerous(const char* f) {
    // Проверка в списке опасных функций
    for (int i = 0; dangerous[i]; i++) {
        if (strcmp(f, dangerous[i]) == 0) {
            return 2;  // Найдена опасная функция
        }
    }
    
    // Проверка в списке функций с предупреждениями
    for (int i = 0; warning[i]; i++) {
        if (strcmp(f, warning[i]) == 0) {
            return 1;  // Найдена функция с предупреждением
        }
    }
    
    return 0;  // Функция не найдена в списках (считаем безопасной)
}

/*
 * ФУНКЦИЯ: skip_line()
 * 
 * Назначение: Определяет, нужно ли пропускать строку при анализе
 * Пропускает строки, содержащие комментарии и строковые литералы,
 * чтобы избежать ложных срабатываний.
 * 
 * Аргументы:
 *   line - строка для проверки
 * 
 * Возвращает:
 *   1 - строка должна быть пропущена (комментарий или внутри строкового литерала)
 *   0 - строку нужно анализировать
 */
int skip_line(const char* line) {
    int in_string = 0;   // Флаг: находимся внутри строкового литерала
    int in_comment = 0;  // Флаг: находимся внутри многострочного комментария
    
    // Проход по всем символам строки
    for (const char *s = line; *s; s++) {
        // ОБРАБОТКА СТРОКОВЫХ ЛИТЕРАЛОВ
        // Если находим кавычку, и она не экранирована (\"), меняем состояние
        if (*s == '"' && (s == line || *(s-1) != '\\')) {
            in_string = !in_string;  // Переключаем флаг
        }
        
        // Если находимся внутри строки, пропускаем дальнейший анализ
        // (комментарии внутри строк не должны учитываться)
        if (in_string) {
            continue;
        }
        
        // ОДНОСТРОЧНЫЕ КОММЕНТАРИИ (//)
        // Если находим "//", вся строка - комментарий
        if (s[0] == '/' && s[1] == '/') {
            return 1;  // Пропустить строку
        }
        
        // МНОГОСТРОЧНЫЕ КОММЕНТАРИИ (начало: /*)
        if (s[0] == '/' && s[1] == '*') {
            in_comment = 1;  // Входим в комментарий
        }
        
        // МНОГОСТРОЧНЫЕ КОММЕНТАРИИ (конец: */)
        if (in_comment && s[0] == '*' && s[1] == '/') {
            in_comment = 0;  // Выходим из комментария
            s++;  // Пропускаем символ '/', чтобы не обрабатывать его повторно
        }
    }
    
    // Если вышли из цикла, но всё ещё в комментарии,
    // значит строка заканчивается незакрытым комментарием
    return in_comment;
}

/*
 * ГЛАВНАЯ ФУНКЦИЯ: main()
 * 
 * Назначение: Точка входа программы, анализ переданных файлов
 * 
 * Аргументы командной строки:
 *   argv[0] - имя программы
 *   argv[1]... - файлы для анализа
 */
int main(int argc, char **argv) {
    // ========== НАСТРОЙКА ЛОГИРОВАНИЯ ==========
    // Динамическое определение имени пользователя для syslog
    struct passwd *pw = getpwuid(getuid());  // Получаем информацию о текущем пользователе
    const char *username = pw ? pw->pw_name : "user-12-31";  // Используем имя или fallback
    
    // Открываем соединение с syslog
    // LOG_PID - добавлять PID процесса к сообщениям
    // LOG_NDELAY - немедленно открывать соединение
    // LOG_USER - facility для пользовательских процессов
    openlog(username, LOG_PID | LOG_NDELAY, LOG_USER);
    syslog(LOG_INFO, "Запуск анализатора, UID=%d", getuid());

    // ========== БЕЗОПАСНОСТЬ: ПРОВЕРКА ПРИВИЛЕГИЙ ==========
    uid_t ruid, euid, suid;  // Реальный, эффективный и сохранённый UID
    
    // Получаем все три UID
    getresuid(&ruid, &euid, &suid);
    
    // Если запущено от root (euid == 0) но реальный пользователь не root,
    // понижаем привилегии для безопасности
    if (euid == 0 && ruid != 0) {
        if (seteuid(ruid) == 0) {
            syslog(LOG_INFO, "Привилегии успешно понижены до UID=%d", ruid);
        }
    }

    // ========== ПРОВЕРКА АРГУМЕНТОВ ==========
    if (argc < 2) {
        // Неправильное использование: выводим справку
        fprintf(stderr, "Использование: %s файл1.c [файл2.c ...]\n", argv[0]);
        closelog();
        return 1;
    }

    // ========== НАСТРОЙКА РЕГУЛЯРНОГО ВЫРАЖЕНИЯ ==========
    // Регулярное выражение для поиска вызовов функций:
    // \b - граница слова
    // ([a-zA-Z_][a-zA-Z0-9_]*) - имя функции (начинается с буквы или _, затем буквы/цифры/_)
    // [ \t]* - ноль или более пробелов/табуляций
    // \( - открывающая скобка
    regex_t re;
    if (regcomp(&re, "\\b([a-zA-Z_][a-zA-Z0-9_]*)[ \t]*\\(", REG_EXTENDED) != 0) {
        syslog(LOG_ERR, "Ошибка компиляции регулярного выражения");
        closelog();
        return 1;
    }

    // ========== ОБРАБОТКА КАЖДОГО ФАЙЛА ==========
    for (int i = 1; i < argc; i++) {
        // Открываем файл для чтения
        FILE *f = fopen(argv[i], "r");
        if (!f) {
            syslog(LOG_WARNING, "Не удалось открыть файл: %s", argv[i]);
            continue;  // Пропускаем проблемный файл, продолжаем со следующим
        }

        char *line = NULL;    // Указатель на буфер строки (выделяется getline)
        size_t len = 0;       // Размер выделенного буфера
        int lineno = 0;       // Номер текущей строки

        // ========== ЧТЕНИЕ ФАЙЛА ПОСТРОЧНО ==========
        while (getline(&line, &len, f) != -1) {
            lineno++;  // Увеличиваем счётчик строк
            
            // Пропускаем строки с комментариями и строковыми литералами
            if (skip_line(line)) {
                free(line);   // Освобождаем память, выделенную getline
                line = NULL;  // Сбрасываем указатель
                continue;     // Переходим к следующей строке
            }

            // ========== ПОИСК ВЫЗОВОВ ФУНКЦИЙ В СТРОКЕ ==========
            regmatch_t pm[2];  // Массив для хранения совпадений (0 - всё, 1 - группа)
            char *p = line;    // Указатель для поиска в строке
            
            // Ищем все вызовы функций в текущей строке
            while (regexec(&re, p, 2, pm, 0) == 0) {
                // ========== ИЗВЛЕЧЕНИЕ ИМЕНИ ФУНКЦИИ ==========
                char func[64] = {0};  // Буфер для имени функции
                int l = pm[1].rm_eo - pm[1].rm_so;  // Длина имени функции
                
                // БЕЗОПАСНОСТЬ: Проверяем, не превышает ли длина размер буфера
                if (l >= 64) l = 63;  // Оставляем место для нулевого терминатора
                
                // Копируем имя функции из строки в буфер
                strncpy(func, p + pm[1].rm_so, l);
                func[l] = '\0';  // Гарантированно завершаем строку

                // ========== ПРОВЕРКА УРОВНЯ ОПАСНОСТИ ==========
                int lvl = is_dangerous(func);
                
                if (lvl == 2) {
                    // ОПАСНАЯ ФУНКЦИЯ: вывод красным жирным текстом
                    printf("\033[1;31mОПАСНО\033[0m: %s:%d → %s()\n",
                           basename(argv[i]), lineno, func);
                    syslog(LOG_WARNING, "ОПАСНО %s:%d %s()", 
                           basename(argv[i]), lineno, func);
                } 
                else if (lvl == 1) {
                    // ФУНКЦИЯ С ПРЕДУПРЕЖДЕНИЕМ: вывод жёлтым жирным текстом
                    printf("\033[1;33mПРЕДУПРЕЖДЕНИЕ\033[0m: %s:%d → %s()\n",
                           basename(argv[i]), lineno, func);
                    syslog(LOG_NOTICE, "ПРЕДУПРЕЖДЕНИЕ %s:%d %s()", 
                           basename(argv[i]), lineno, func);
                }
                
                // ========== ПЕРЕХОД К СЛЕДУЮЩЕМУ СОВПАДЕНИЮ ==========
                // Сдвигаем указатель на конец текущего совпадения
                p += pm[0].rm_eo;
            }
            
            // ========== ОЧИСТКА ПАМЯТИ ==========
            free(line);    // Освобождаем память, выделенную getline
            line = NULL;   // Сбрасываем указатель
        }
        
        // Закрываем файл
        fclose(f);
    }

    // ========== ОЧИСТКА РЕСУРСОВ ==========
    regfree(&re);    // Освобождаем память регулярного выражения
    closelog();      // Закрываем соединение с syslog
    
    return 0;
}
